spring-data
Projects related to various spring data types.

Spring- mongodb config settings.

<context:annotation-config />

<!-- Connection to MongoDB server -->
<mongo:db-factory id="mongoDbFactory" dbname="test"
    host="localhost" port="27017" />

<mongo:mapping-converter id="mongoConverter"
    base-package="com.oreilly.springdata.mongodb">
    <mongo:custom-converters base-package="com.oreilly.springdata.mongodb" />
</mongo:mapping-converter>

<!-- MongoDB Template -->
<bean id="mongoTemplate" class="org.springframework.data.mongodb.core.MongoTemplate">
    <constructor-arg name="mongoDbFactory" ref="mongoDbFactory" />
    <constructor-arg ref="mongoConverter" />
    <property name="writeConcern" value="SAFE" />
</bean>

<!-- Enable the auto scan of all the mongodb repositories -->
<mongo:repositories base-package="com.abhi.mongodb.repositories" />

<bean id="customerManager" class="com.abhi.mongodb.service.CustomerService" />
Maven dependencies

    <!-- mongodb java driver -->
    <dependency>
        <groupId>org.mongodb</groupId>
        <artifactId>mongo-java-driver</artifactId>
        <version>2.11.3</version>
    </dependency>

    <!-- Spring MongoDB dependencies -->
    <dependency>
        <groupId>org.springframework.data</groupId>
        <artifactId>spring-data-mongodb</artifactId>
        <version>1.3.2.RELEASE</version>
    </dependency>
@Document @CompoundIndexes({ @CompoundIndex(name = "email_index", def = "{'lastName': 1, 'emailId': -1}") }) public class Customer extends AbstractDocument { @Field("firstName") private String firstName;

@Field("lastName")
private String lastName;

@Field("age")
private Integer age;

@Field("emailAddress")
@Indexed(unique = true)
private EmailAddress emailAddress;

@DBRef
private List<Address> addresses;

@PersistenceConstructor
public Customer(String firstName, String lastName, Integer age) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.age = age;
}

public String getFirstName() {
    return firstName;
}

public void setFirstName(String firstName) {
    this.firstName = firstName;
}

public String getLastName() {
    return lastName;
}

public void setLastName(String lastName) {
    this.lastName = lastName;
}

public Integer getAge() {
    return age;
}

public void setAge(Integer age) {
    this.age = age;
}

public EmailAddress getEmailAddress() {
    return emailAddress;
}

public void setEmailAddress(EmailAddress emailAddress) {
    this.emailAddress = emailAddress;
}

public List<Address> getAddresses() {
    return addresses;
}

public void setAddresses(List<Address> addresses) {
    this.addresses = addresses;
}
}

public final class EmailAddress {

private static final String EMAIL_REGEX = "^[_A-Za-z0-9-]+(\\.[_A-Za-z0-9-]+)*@[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$";
private static final Pattern PATTERN = Pattern.compile(EMAIL_REGEX);

@Field("emailAddress")
private final String emailAddress;

public EmailAddress(String emailAddress) {
    Assert.isTrue(isValid(emailAddress), "Invalid email address!");
    this.emailAddress = emailAddress;
}

@Override
public String toString() {
    return emailAddress;
}

@Override
public boolean equals(Object obj) {

    if (this == obj) {
        return true;
    }

    if (!(obj instanceof EmailAddress)) {
        return false;
    }

    EmailAddress that = (EmailAddress) obj;
    return this.emailAddress.equals(that.emailAddress);
}

@Override
public int hashCode() {
    return emailAddress.hashCode();
}

@Component
static class EmailAddressToStringConverter implements Converter<EmailAddress, String> {
    @Override
    public String convert(EmailAddress source) {
        return source == null ? null : source.emailAddress;
    }
}

@Component
static class StringToEmailAddressConverter implements Converter<String, EmailAddress> {
    public EmailAddress convert(String source) {
        return StringUtils.hasText(source) ? new EmailAddress(source) : null;
    }
}

public static boolean isValid(String candidate) {
    return candidate == null ? false : PATTERN.matcher(candidate).matches();
}
}

@Document public class Address extends AbstractDocument { @Field("street") private final String street;

@Field("city")
private final String city; 

@Field("country")
private final String country;

public Address(String street, String city, String country) 
{
    Assert.hasText(street, "Street must not be null or empty!");
    Assert.hasText(city, "City must not be null or empty!");
    Assert.hasText(country, "Country must not be null or empty!");

    this.street = street;
    this.city = city;
    this.country = country;
}

public String getStreet() {
    return street;
}

public String getCity() {
    return city;
}

public String getCountry() {
    return country;
}
}

Added new method to Generic DAO class.

@Override public Integer count(String queryName, Map params) throws DataAccessException { Query queryObject = entityManager.createNamedQuery(queryName); if (params != null) { for (Map.Entry entry : params.entrySet()) { queryObject.setParameter(entry.getKey(), entry.getValue()); } } return ((Number)queryObject.getSingleResult()).intValue(); }

http://maciejwalkowiak.pl/blog/2012/04/30/spring-data-mongodb-cascade-save-on-dbref-objects/ http://jimmyraywv.blogspot.in/2012/05/mongodb-and-spring-data.html http://www.mongovue.com/

http://www.mongodb.com/presentations/webinar-relational-databases-mongodb-what-you-need-know